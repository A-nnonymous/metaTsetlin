#pragma once
#include <vector>
#include <string>
#include <string_view>
#include <initializer_list>
#include <functional>
#include "io.h"

using std::vector;
using std::string;

typedef std::function<vector<vector<int>>(const vector<string>&)> seqParseFunc;
typedef std::function<vector<string>(const vector<vector<int>>&, int, int)> seqDeparseFunc;// signal and offset.

struct pattern
{
    string sequence;
    double value;
    pattern operator=(pattern other)
    {
        this->sequence = other.sequence;
        this->value = other.value;
        return *this;
    }
};

///////////////////////////// Tsetlin machine specified maps /////////////////////////////

static std::unordered_map<char,vector<int>> dnaSeq2Vec = 
{
    {'A', vector<int>{1, 0, 0, 0}},
    {'a', vector<int>{1, 0, 0, 0}},
    {'T', vector<int>{0, 1, 0, 0}},
    {'t', vector<int>{0, 1, 0, 0}},
    {'C', vector<int>{0, 0, 1, 0}},
    {'c', vector<int>{0, 0, 1, 0}},
    {'G', vector<int>{0, 0, 0, 1}},
    {'g', vector<int>{0, 0, 0, 1}},
};

static std::unordered_map<char,vector<int>> rnaSeq2Vec = 
{
    {'A', vector<int>{1, 0, 0, 0}},
    {'a', vector<int>{1, 0, 0, 0}},
    {'U', vector<int>{0, 1, 0, 0}},
    {'u', vector<int>{0, 1, 0, 0}},
    {'C', vector<int>{0, 0, 1, 0}},
    {'c', vector<int>{0, 0, 1, 0}},
    {'G', vector<int>{0, 0, 0, 1}},
    {'g', vector<int>{0, 0, 0, 1}},
};
/// Used to interpret tsetlin literal as nucleotide.
static std::unordered_map<int,char> tag2CharPos= 
{
    {0, '_'},
    {1, 'A'},
    {2, 'U'},
    {4, 'C'},
    {8, 'G'},
};

static std::unordered_map<int,char> tag2CharNeg= 
{
    {0, '_'},
    {1, 'W'},
    {2, 'X'},
    {4, 'Y'},
    {8, 'Z'},
};

static vector<std::unordered_map<int,string>> feature2StrMap(1);
///////////////////////////// Tsetlin machine specified maps /////////////////////////////

vector<int> siRNA2SIG(const string &raw_string)noexcept;
vector<double> seqGC(const vector<string> &rawStrings)noexcept;


class Parser{
private:
    /////////////// Data shared to decoder////////////////
    friend class                Deparser;
    vector<int>                 workRange;
    vector<vector<double>>      discreteThreshold;
    int                         funcNum;
    /////////////// Data shared to decoder////////////////

    vector<seqParseFunc>        funcs;
    vector<vector<int>>         parseSeqs2NucSig(const vector<string> &rawStrings);
    vector<vector<int>>         parseSeqs2GCSig(const vector<string> &rawStrings);

public:
    Parser()
    {
        //////////// Extensible part (but forgive my ugly code, sry)//////////////
        seqParseFunc Nuc =
        [this](const vector<string> &rawStrings)
        -> vector<vector<int>> 
        {
            return this->parseSeqs2NucSig(rawStrings);
        };

        seqParseFunc GC =
        [this](const vector<string> &rawStrings)
        -> vector<vector<int>> 
        {
            return this->parseSeqs2GCSig(rawStrings);
        };

        funcs.emplace_back(Nuc);
        funcs.emplace_back(GC);
        //////////// Extensible part (but forgive my ugly code, sry)//////////////

        funcNum = funcs.size();
        workRange.resize(funcNum + 1, 0);
        discreteThreshold.resize(funcNum - 1, vector<double>(4,0)); // Nucleotide transform need no threshold.
    }

private:
    // Concatenation of signals generated by various parsers.
    vector<vector<int>> concatenate(vector<vector<vector<int>>> &signals)
    {
        auto sampleLength = 0;
        auto sampleNum = signals[0].size(); // Assuming no discard of samples in all parser.
        vector<vector<int>> result(sampleNum);
        // Adding up all feature`s length.
        for(auto i = 0 ; i < funcNum; i++)
        {
            sampleLength += signals[i][0].size();
            workRange[i + 1] = sampleLength; // Range end.
        }
        // Reserve and put all generated feature in a new 2d vector
        for (auto sampleIdx = 0; sampleIdx < sampleNum; sampleIdx++)
        {
            result[sampleIdx].reserve(sampleLength);
            for(auto funcIdx = 0; funcIdx < funcNum; funcIdx++)
            {
                result[sampleIdx].insert(   result[sampleIdx].end(),
                                            signals[funcIdx][sampleIdx].begin(),
                                            signals[funcIdx][sampleIdx].end());
            }
        }
        return result;
    }
public:
    vector<vector<int>> parse(const vector<string> &rawStrings)
    {
        auto funcSize = funcs.size();
        vector<vector<int>> result;
        vector<vector<vector<int>>> seperateResult(funcSize);
        for(auto fIdx = 0; fIdx < funcSize; fIdx++)
        {
            seperateResult[fIdx] = funcs[fIdx](rawStrings);
        }
        result = this->concatenate(seperateResult);
        return result;
    }
};

class Deparser{
private:
    //////////////////Received from encoder////////////////////
    const vector<int>               &workRange;
    const vector<vector<double>>    &discreteThreshold; // initialized to be invalid until parse complete.
    //////////////////Received from encoder////////////////////
    int                             funcNum;
    vector<seqDeparseFunc>          funcs;
    vector<string>                  deparseNucSig2Seq(const vector<vector<int>> &rawSignals, const int start, const int end);
    vector<string>                  deparseGCSig2Seq(const vector<vector<int>> &rawSignals, const int start, const int end);

public:
    Deparser(const Parser &psr):
        workRange(psr.workRange), discreteThreshold(psr.discreteThreshold)
    {
        seqDeparseFunc Nuc =
        [this](const vector<vector<int>> &rawSignals, const int start, const int end)
        -> vector<string>
        {
            return this->deparseNucSig2Seq(rawSignals, start, end);
        };

        seqDeparseFunc GC =
        [this](const vector<vector<int>> &rawSignals, const int start, const int end)
        -> vector<string>
        {
            return this->deparseNucSig2Seq(rawSignals, start, end);
        };
        funcs.emplace_back(Nuc);
        funcs.emplace_back(GC);
        funcNum = funcs.size();
    }

private:
    // Concatenation of discriptions generated by various deparsers.
    vector<string> concatenate(const vector<vector<string>> &discriptions)const
    {
        auto sampleNum = discriptions[0].size();    // Assuming always exist a discription of all samples.
        vector<string> result(sampleNum);
        // Adding up all feature`s length.
        for (auto sampleIdx = 0; sampleIdx < sampleNum; sampleIdx++)
        {
            for(auto funcIdx = 0; funcIdx < funcNum; funcIdx++)
            {
                if(discriptions[funcIdx][sampleIdx].empty())
                {
                    return vector<string>();
                }
                else
                {
                    result[sampleIdx] += discriptions[funcIdx][sampleIdx];
                }
                if(funcIdx != funcNum - 1) result[sampleIdx] += ",";
            }
        }
        return result;
    }
public:
    vector<string> deparse(const vector<vector<int>> &rawSignals)const
    {
        vector<string> result;
        vector<vector<string>> seperateResult(funcNum);
        for(auto fIdx = 0; fIdx < funcNum; fIdx++)
        {
            seperateResult[fIdx] = funcs[fIdx](rawSignals, workRange[fIdx], workRange[fIdx + 1]);
        }
        result = this->concatenate(seperateResult);
        return result;
    }
};

/// @brief Wraper of parser and deparser class, require full life-span throughout whole training
class nucTransformer{
private:
    Parser parser;
    Deparser deparser = Deparser(parser);
    vector<double> responseThreshold;

public:
    nucTransformer()noexcept{};
    dataset parseAndDivide( const vector<string> &seqs,
                            const vector<double> &responses,
                            double trainRatio, int classes)
    {
        ////////// arg check ////////////
        bool isRightLength = seqs.size() == responses.size();
        bool isPossibleDivision = classes <= seqs.size();
        if(!isRightLength)[[unlikely]] std::cout<<"Data length corrupted."<<std::endl;
        if(!isPossibleDivision)[[unlikely]] std::cout<<"Can't divide data into "<<classes<<" parts."<<std::endl;
        if(!isRightLength || !isPossibleDivision)[[unlikely]] return dataset();
        ////////// arg check ////////////
        
        auto totalData = parser.parse(seqs);

        ////////// Response threshold picking////////////
        responseThreshold = getFairThreshold<double> (responses, classes);
        ////////// Response threshold picking////////////

        ////////// Sequence prepare and random chosing//////////////
        std::discrete_distribution<>    d({1-trainRatio, trainRatio});
        pcg_extras::seed_seq_from<std::random_device> seed_source;
        pcg64_fast                      _rng(seed_source);
        dataset result;

        vector<vector<int>>     trainData;
        vector<vector<int>>     trainResponse;
        vector<vector<int>>     testData;
        vector<vector<int>>     testResponse;

        vector<int> thisResponse;
        for (int i = 0; i < seqs.size(); i++)
        {
            thisResponse = getDiscreteResponse(responseThreshold, responses[i]);
            if(d(_rng)==1)[[likely]]    // Picked to training set.
            {
                trainData.emplace_back(totalData[i]);
                trainResponse.emplace_back(thisResponse);
            }
            else[[unlikely]]            // Picked to test set.
            {
                testData.emplace_back(totalData[i]);
                testResponse.emplace_back(thisResponse);
            }
        }
        trainData.shrink_to_fit();
        trainResponse.shrink_to_fit();
        testData.shrink_to_fit();
        testResponse.shrink_to_fit();
        ////////// Sequence prepare and random chosing//////////////
        
        result.responseSize = classes;
        result.responseThreshold = responseThreshold;
        result.trainData = trainData;
        result.trainResponse = trainResponse;
        result.testData = testData;
        result.testResponse = testResponse;
        result.trainSize = trainData.size();
        result.testSize = testData.size();

        //////////////////// verbose////////////////////
        std::cout<< "Dataset preparation completed."<<std::endl;
        std::cout<<"Actual training set ratio is "<< trainData.size()/(double)seqs.size()<<std::endl;
        std::cout<<"Balanced threshold for discrete response is:\t";
        for (auto i = 0; i < responseThreshold.size(); i++)
        {
            std::cout<< responseThreshold[i]<<"\t";
        }
        std::cout<<std::endl;
        //////////////////// verbose////////////////////
        return result;
    }
    
    void deparseAndOutput(  const TsetlinMachine::model &trainedModel,
                            double precision,
                            string outputPath)const
    {
        // TODO: Auto detect and use user-defined or default tierTags to divide output.
        //          modify the Tsetlin machine initialization process logic.
        if(!outputPath.ends_with("/"))outputPath+="/";
        std::filesystem::create_directories(outputPath);

        auto tierNum = trainedModel.tierTags.size();
        vector<vector<string>> positivePatterns(tierNum);
        vector<vector<string>> negativePatterns(tierNum);
        for(auto tierIdx = 0; tierIdx < tierNum; tierIdx++)
        {
            positivePatterns[tierIdx] = deparser.deparse(trainedModel.automatas[tierIdx].positiveClauses);
            negativePatterns[tierIdx] = deparser.deparse(trainedModel.automatas[tierIdx].negativeClauses);
            string prefix = outputPath + "/prec" + std::to_string(precision) + "/" + trainedModel.tierTags[tierIdx] +"/";
            std::filesystem::create_directories(prefix);
            std::ofstream positive(prefix + "positivePatterns.csv");
            std::ofstream negative(prefix + "negativePatterns.csv");
            for(auto i=0; i < positivePatterns[tierIdx].size(); i++)
            {
                positive << positivePatterns[tierIdx][i];
                if(i != positivePatterns[tierIdx].size() - 1)[[likely]]
                {
                    positive<< "\n";
                }
            }
            for(auto i=0; i < negativePatterns[tierIdx].size(); i++)
            {
                negative << negativePatterns[tierIdx][i];
                if(i != negativePatterns[tierIdx].size() - 1)[[likely]]
                {
                    negative << "\n";
                }
            }
        }
    }
};